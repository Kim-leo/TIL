# 시간 복잡도 비교 | Comparing time complexity
### 1부터 n까지의 합 구하기
```swift
func sumFromOne(upto n: Int) -> Int {
    var result = 0
    for i in 1...n {
        result += i
    }
    return result
}

sumFromOne(upto: 10000)
```

위 Swift 코드는 1부터 n까지의 합을 찾는 함수이다.

이는 코드를 1만번 반복하고 값을 50,005,000 을 반환할 것이다. 인풋 10,000 만큼 코드를 수행했으니 시간 복잡도는 __O(n)__ 이 된다.

### 컴파일된 코드를 불러오면 조금 더 빨라지긴 한다.
```swift
func sumFromOne(upto n: Int) -> Int {
    (1...n).reduce(0, +)
}

sumFromOne(upto: 10000)
```
바로 위의 코드는 첫 번째 코드와 같은 기능을 하는데, 표준 라이브러리에서 컴파일된 코드를 불러오기 때문에 첫 번째 코드보다 더 빨리 수행된다.
하지만 이 역시 인풋 10,000만큼 수행되므로 시간 복잡도는 __O(n)__ 이다.

### 더 단순하고 빠르게
```swift
func sumFromOne(upto n: Int) -> Int {
    (n + 1) * n / 2
}

sumFromOne(upto: 10000)
```
위 코드는 1부터 n까지의 합을 구하는 공식으로 수학 시간에 분명히 배웠던 기억이 있다. 
이 알고리즘은 단순한 산술 형태를 띄고 있으며 시간 복잡도는 무려 __O(1)__ 이다. 앞선 두 개의 코드는 이 것보다 절대 수행 시간이 빨라질 수 없다.

### 시간 복잡도 알고리즘 비교하기
<img width="799" alt="스크린샷 2024-02-27 오후 12 06 29" src="https://github.com/Kim-leo/TIL/assets/77371366/010f1ac3-9695-4dde-89c9-c4c00031ac33">

n의 값이 커질수록 각 시간 복잡도에 대한 차이는 명백하며 
평방 시간 (n^2) 만 보더라도 인풋이 1,000개 밖에 되지 않지만 이에 대한 수행 시간은 100,000 이다.

더 단순하고 직관적이며 빠른 알고리즘을 탐구하고 선택, 적용해야 하는 이유가 여기 있다.
