# Swift 표준 라이브러리 | Array, Dictionary and Set
Swift 표준 라이브러리는 Swift 언어의 핵심 요소를 포함하는 프레임워크이다. 내부에는 스위프트 앱을 구축하는 데 도움이 되는 다양한 도구와 유형이 있으며, 자신만의 맞춤형 데이터 구조를 구축하기 전에 Swift 표준 라이브러리가 이미 제공하고 있는 기본 데이터 구조를 이해하는 것이 중요하다.

이번 글에서는 배열(Array), 딕셔너리(Dictionary), 집합(Set) 에 대해 다루지만, 각각 만드는 법이나 디테일한 메소드 보다는, 각각의 특징들과 주요 메소드의 시간 복잡도 등과 같은 __자료구조 관점__ 에서 이 세 프레임워크를 바라보고자 한다. 

## 배열 | Array
배열은 원소들의 순서가 지정된 집합을 저장하기 위한 범용적인 컨테이너이며, 모든 종류의 Swift 프로그램에서 일반적으로 사용된다. 

```swift
let people = ["Brian", "Stanley", "Ringo"]
```

Swift는 프로토콜(protocol)을 사용하여 배열을 정의한다. 이러한 프로토콜은 각각 배열에 더 많은 기능을 계층화한다. 예를 들어, 배열은 시퀀스(Sequence)이며, 이는 적어도 한 번은 배열을 통해 반복할 수 있으며, 컬렉션(Collection)으로서, 이는 여러 번 배열 구조를 해치지 않게 통과하고 subscript 연산자를 사용하여 액세스할 수 있다는 것을 의미한다. 배열은 효율성을 보장하는 RandomAccessCollection(랜덤 액세스 컬렉션)이다.

Swift 배열은 어떤 type이든 작동할 수 있기 때문에 일반적인 Collection으로 알려져 있다. 사실, 스위프트 표준 라이브러리의 대부분은 generic code로 구축되어 있다.

다른 데이터 구조와 마찬가지로 주목해야 할 몇 가지 특징이 있다. 이 중 첫 번째는 __순서__ 개념이다.

### 순서 | Order
배열의 요소들은 명시적으로 순서가 정해진다. 위의 people 배열을 예로 들면, "Stanley" 앞에 "Brian"이 나온다.
배열의 모든 요소는 대응하는 0 기반 정수 인덱스를 가지고 있다. 예를 들어 위의 예제에서 나온 people 배열에는 각 요소에 하나씩 대응하는 3개의 인덱스가 있다. 배열에 있는 요소의 값은 다음과 같이 적으면 얻을 수 있다.
```swift
people[0] // "Brian"
people[1] // "Stanley"
people[2] // "Ringo
```
순서는 배열 데이터 구조에 의해 정의되므로 당연한 것으로 여겨져서는 안 된다. 딕셔너리(Dictionary)와 같은 일부 데이터 구조는 순서 개념이 약하다.

### Random-access
랜덤 액세스는 데이터 구조가 요소 검색을 일정한 시간 내에 처리할 수 있는지 여부를 주장할 수 있는 특성이다. 예를 들어, people 배열에서 "Ringo"를 가져오는 데는 일정한 시간이 걸리는데, 이는 배열의 성능을 당연한 것으로 여겨서는 안 된다. linked list나 tree와 같은 다른 데이터 구조는 일정한 시간 액세스를 갖지 않는다.

## 배열의 성능 | Array performance
랜덤 액세스 컬렉션 외에도 다른 성능 영역은 개발자로서 특히 데이터 구조가 포함된 데이터의 양을 늘려야 할 때 얼마나 잘 작동하는지 또는 잘 작동하지 않는지에 대해 중요하다. 배열의 경우 이는 아래 두 가지 요소에 따라 다르다.

### 삽입 위치 | Insertion location
첫 번째 요소는 __배열 안에 새로운 요소를 삽입__ 하는 것이다. 배열에 요소를 추가하는 가장 효율적인 방법은 배열의 끝에 요소를 추가하는 것이다.
```swift
people.append("Charles")
print(people) // prints ["Brian", "Stanley", "Ringo", "Charles"]
```
append 메소드를 사용하여 "Charles"를 삽입하면 배열의 끝에 문자열이 배치되며 시간 복잡도는 __상수 시간(O(1))__ 연산이다. 이 연산을 수행하는 데 걸리는 시간은 배열이 아무리 커지더라도 동일하게 유지된다. 

그러나 배열의 맨 가운데와 같은 특정 위치에 요소를 삽입해야 하는 경우가 있다. 배열의 끝을 제외한 다른 곳에서 새 요소를 삽입하면 요소가 뒤로 섞여서 새 요소를 위한 공간을 만들어야 한다.
```swift
people.insert("Andy", at: 0)
// ["Andy", "Brian", "Stanley", "Ringo", "Charles"]
```
정확히 말하면, 모든 요소는 인덱스 하나씩 뒤로 이동해야 하고, 이를 위해서는 __n 단계__ 가 걸린다. 배열에 있는 요소의 수가 두 배가 되면, 이 삽입 작업에 필요한 시간도 두 배가 될 것이다.

collection 앞에 요소를 삽입하는 것이 프로그램의 일반적인 작업인 경우 데이터를 보관하기 위해 다른 데이터 구조를 고려해야 할 수도 있다.

삽입 속도를 결정하는 두 번째 요소는 __배열의 용량__ 이다. 프로그램 내부적으로 Swift 배열의 요소를 위해 미리 정해진 공간이 할당된다. 이미 최대 용량에 있는 배열에 새 요소를 추가하려고 하면, 배열 자체가 더 많은 요소를 사용할 수 있도록 더 많은 공간을 만들기 위해 재구성되어야 하는데, 이는 배열의 현재 요소를 메모리의 새롭고 더 큰 컨테이너에 복사함으로써 수행된다. 그러나 배열의 각 요소를 확인하여 복사해야 하기 때문에 작성 시간이 늘어날 수 있다는 위험이 있다.

위 작업은 복사본을 만들었을 때 마지막에 삽입하더라도 n번의 단계를 거쳐 완성할 수 있다는 것을 의미한다. 하지만 표준 라이브러리는 이러한 복사본 생성에 필요한 시간을 최소화하는 방법을 사용하는데, 저장 공간이 부족하여 복사본을 복사해야 할 때마다 용량이 두 배로 증가한다.

