# Swift 표준 라이브러리 | Array, Dictionary and Set
Swift 표준 라이브러리는 Swift 언어의 핵심 요소를 포함하는 프레임워크이다. 내부에는 스위프트 앱을 구축하는 데 도움이 되는 다양한 도구와 유형이 있으며, 자신만의 맞춤형 데이터 구조를 구축하기 전에 Swift 표준 라이브러리가 이미 제공하고 있는 기본 데이터 구조를 이해하는 것이 중요하다.

이번 글에서는 배열(Array), 딕셔너리(Dictionary), 집합(Set) 에 대해 다루지만, 각각 만드는 법이나 디테일한 메소드 보다는, 각각의 특징들과 주요 메소드의 시간 복잡도 등과 같은 __자료구조 관점__ 에서 이 세 프레임워크를 바라보고자 한다. 

# 배열 | Array
배열은 원소들의 순서가 지정된 집합을 저장하기 위한 범용적인 컨테이너이며, 모든 종류의 Swift 프로그램에서 일반적으로 사용된다. 

```swift
let people = ["Brian", "Stanley", "Ringo"]
```

Swift는 프로토콜(protocol)을 사용하여 배열을 정의한다. 이러한 프로토콜은 각각 배열에 더 많은 기능을 계층화한다. 예를 들어, 배열은 시퀀스(Sequence)이며, 이는 적어도 한 번은 배열을 통해 반복할 수 있으며, 컬렉션(Collection)으로서, 이는 여러 번 배열 구조를 해치지 않게 통과하고 subscript 연산자를 사용하여 액세스할 수 있다는 것을 의미한다. 배열은 효율성을 보장하는 RandomAccessCollection(랜덤 액세스 컬렉션)이다.

Swift 배열은 어떤 type이든 작동할 수 있기 때문에 일반적인 Collection으로 알려져 있다. 사실, 스위프트 표준 라이브러리의 대부분은 generic code로 구축되어 있다.

다른 데이터 구조와 마찬가지로 주목해야 할 몇 가지 특징이 있다. 이 중 첫 번째는 __순서__ 개념이다.

### 순서 | Order
__배열의 요소들은 명시적으로 순서가 정해진다.__ 위의 people 배열을 예로 들면, "Stanley" 앞에 "Brian"이 나온다.
배열의 모든 요소는 대응하는 0 기반 정수 인덱스를 가지고 있다. 예를 들어 위의 예제에서 나온 people 배열에는 각 요소에 하나씩 대응하는 3개의 인덱스가 있다. 배열에 있는 요소의 값은 다음과 같이 적으면 얻을 수 있다.
```swift
people[0] // "Brian"
people[1] // "Stanley"
people[2] // "Ringo
```
순서는 배열 데이터 구조에 의해 정의되므로 당연한 것으로 여겨져서는 안 된다. 딕셔너리(Dictionary)와 같은 일부 데이터 구조는 순서 개념이 약하다.

### Random-access
랜덤 액세스는 데이터 구조가 요소 검색을 일정한 시간 내에 처리할 수 있는지 여부를 주장할 수 있는 특성이다. 예를 들어, people 배열에서 "Ringo"를 가져오는 데는 일정한 시간이 걸리는데, 이는 배열의 성능을 당연한 것으로 여겨서는 안 된다. linked list나 tree와 같은 다른 데이터 구조는 일정한 시간 액세스를 갖지 않는다.

## 배열의 성능 | Array performance
랜덤 액세스 컬렉션 외에도 다른 성능 영역은 개발자로서 특히 데이터 구조가 포함된 데이터의 양을 늘려야 할 때 얼마나 잘 작동하는지 또는 잘 작동하지 않는지에 대해 중요하다. 배열의 경우 이는 아래 두 가지 요소에 따라 다르다.

### 삽입 위치 | Insertion location
첫 번째 요소는 __배열 안에 새로운 요소를 삽입__ 하는 것이다. 배열에 요소를 추가하는 가장 효율적인 방법은 배열의 끝에 요소를 추가하는 것이다.
```swift
people.append("Charles")
print(people) // prints ["Brian", "Stanley", "Ringo", "Charles"]
```
append 메소드를 사용하여 "Charles"를 삽입하면 배열의 끝에 문자열이 배치되며 시간 복잡도는 __상수 시간(O(1))__ 연산이다. 이 연산을 수행하는 데 걸리는 시간은 배열이 아무리 커지더라도 동일하게 유지된다. 

그러나 배열의 맨 가운데와 같은 특정 위치에 요소를 삽입해야 하는 경우가 있다. 배열의 끝을 제외한 다른 곳에서 새 요소를 삽입하면 요소가 뒤로 섞여서 새 요소를 위한 공간을 만들어야 한다.
```swift
people.insert("Andy", at: 0)
// ["Andy", "Brian", "Stanley", "Ringo", "Charles"]
```
정확히 말하면, 모든 요소는 인덱스 하나씩 뒤로 이동해야 하고, 이를 위해서는 __n 단계__ 가 걸린다. 배열에 있는 요소의 수가 두 배가 되면, 이 삽입 작업에 필요한 시간도 두 배가 될 것이다.

collection 앞에 요소를 삽입하는 것이 프로그램의 일반적인 작업인 경우 데이터를 보관하기 위해 다른 데이터 구조를 고려해야 할 수도 있다.

삽입 속도를 결정하는 두 번째 요소는 __배열의 용량__ 이다. 프로그램 내부적으로 Swift 배열의 요소를 위해 미리 정해진 공간이 할당된다. 이미 최대 용량에 있는 배열에 새 요소를 추가하려고 하면, 배열 자체가 더 많은 요소를 사용할 수 있도록 더 많은 공간을 만들기 위해 재구성되어야 하는데, 이는 배열의 현재 요소를 메모리의 새롭고 더 큰 컨테이너에 복사함으로써 수행된다. 그러나 배열의 각 요소를 확인하여 복사해야 하기 때문에 작성 시간이 늘어날 수 있다는 위험이 있다.

위 작업은 복사본을 만들었을 때 마지막에 삽입하더라도 n번의 단계를 거쳐 완성할 수 있다는 것을 의미한다. 하지만 표준 라이브러리는 이러한 복사본 생성에 필요한 시간을 최소화하는 방법을 사용하는데, 저장 공간이 부족하여 복사본을 복사해야 할 때마다 용량이 두 배로 증가한다.

* * *
# 딕셔너리 | Dictionary
딕셔너리는 __key-value__ 쌍을 포함하는 또 다른 일반적인 collection이다. 예를 들어, 아래 코드에 user name과 score가 포함된 딕셔너리가 있다.
```swift
var scores: [String: Int] = ["Eric": 9, "Mark": 12, "Wayne": 1]
```
딕셔너리는 순서에 대한 보장이 없으며 특정 인덱스에 삽입할 수도 없다. 또한 key 유형에 Hashable해야 하는 요구사항이 있다. 아래 구문을 사용하여 딕셔너리에 새 항목을 추가할 수 있다.
```swift
scores["Andrew"] = 0
```
그러면 딕셔너리가 아래와 같이 업데이트된다.
```swift
["Eric": 9, "Mark": 12, "Andrew": 0, "Wayne": 1]
```
"Andrew" key는 딕셔너리의 어딘가에 삽입된다. __딕셔너리는 정렬되지 않으므로 새 항목이 어디에 배치될지 보장할 수 없다는 특징이 있다.__ Collection 프로토콜(protocol)이 제공하는 대로 딕셔너리의 key 값을 여러 번 횡단할 수 있습니다. 이 순서는 정의되지는 않지만 collection이 변경될 때까지 횡단할 때마다 동일하다.

명시적으로 순서에 대한 개념이 없는 것에 대해 이를 상환할 특성이 있다.

__딕셔너리에 새로운 값을 삽입할 때, 배열보다 시간 복잡도가 빠르다.__ 딕셔너리에 삽입하는 데는 항상 일정한 시간이 걸린다. 즉, 시간 복잡도는 __O(1)__ 이다. Lookup 작업에도 일정한 시간이 소요되며, 이는 배열의 처음부터 삽입 지점까지 걸어가야 하는 배열에서 특정 요소를 찾는 것보다 훨씬 빠르다.

* * * 
# 집합 | Set
집합은 고유값(unique values)을 담고 있는 collection 이다. __집합 내 요소들은 서로 중복이 허용되지 않기 때문에 각 값들은 고유하다.__
```swift
var bag: Set<String> = ["Candy", "Juice", "Gummy"]
bag.insert("Candy")
print(bag) // prints ["Candy", "Juice", "Gummy"]
```
배열이나 딕셔너리만큼 집합을 사용하지는 않겠지만, 그래도 알아야 할 중요한 데이터 구조가 될 만큼 일반적인 방법이다. 하지만 한 가지 주의해야 할 점이 있는데, __딕셔너리와 마찬가지로 집합 내의 값은 순서 개념이 없다.__ 집합을 사용하여 데이터를 수집할 때는 이 점을 염두에 두어야 한다.

* * *
# The Swift Collection package
Swift 표준 라이브러리는 가장 중요한 세 가지 데이터 구조(Array, Set, Dictionary)만 구현한다. 

추가적인 데이터 구조는 스위프트 컬렉션 패키지를 확인할 수 있다고 한다. 이 패키지는 새로운 컬렉션 유형이 공식 표준 라이브러리의 일부가 되기 전에 커뮤니티에서 개발하고 테스트할 수 있도록 한다.

아래에는 이 패키지의 데이터 구조 중 하나를 자세히 살펴본다.

# 덱 | Deque
앞서 배열 앞에 요소를 삽입하면 모든 요소가 섞이는 현상이 발생한다는 사실을 배웠다. Deque ("디큐" 아님, "deck"로 발음) 데이터 구조는 얼핏 배열과 같은 목적을 수행하는 것처럼 보인다. 

값을 순서대로 유지하는 범용 컨테이너로 사용할 수 있다. 배열과 마찬가지로 append를 호출하여 Deque에 요소를 추가하거나, 특정 인덱스에서 특정 요소를 제거하려면 remote(at:)를 호출할 수 있다.

실제로 배열과 Deque는 동일한 수집 프로토콜을 구현하기 때문에 인터페이스가 거의 동일하다. 그렇다면 배열보다 Deque를 사용하는 이유는 무엇일까? 시간의 복잡성을 고려하기 전에는 이러한 절충안을 확인하기가 어렵다.

Deque는 __double-ended queue__ 이다. 따라서 Deque는 collection의 앞부분과 뒷부분 모두에서 수정할 수 있도록 최적화한다. __배열과 달리 Deque의 앞부분에 요소를 삽입하거나 제거하는 것은, 시간 복잡도가 빠른 O(1)인 작업이다.__

그렇다면 단점은 무엇일까? 프로그래밍에서는 모든 것이 __Tradeoff__ 이다. 

Deque의 경우 다른 모든 것에 대해 약간 성능이 저하되는 비용으로 전면 수정을 개선하는 것이 중요하다. 프로그램마다 옵션을 검토하고 작업에 가장 적합한 도구를 선택하는 것은 때에 따라 다르다. __앱이 Collection 전면에 자주 수정해야 하는 경우 Deque는 배열보다 훨씬 더 나은 성능을 발휘한다.__ 이는 더 나은 사용자 환경으로 이어질 수 있을 것으로 보인다.

## 그 외
The Swift Collection package에는 __OrderDictionary__ 및 __OrderSet__ 과 같은 추가 데이터 구조가 포함되어 있다. 접두사에서 알 수 있듯이 이러한 데이터 구조는 요소의 순서를 유지하는 딕셔너리와 집합의 변형이다. Deque와 마찬가지로 이러한 데이터 구조에는 몇 가지 성능 균형이 있는데, 
<https://swift.org/blog/swift-collections/> 에서 자세한 내용을 확인할 수 있다.
